//
//  ContextModel+ContextSegment.swift
//
//
//  Created by Kai Shao on 2024/6/16.
//

import Foundation

extension ContextModel {
    public struct ContextSegment: UUIDContextModelKind, TokenKind {
        public static var typeName: String {
            "ContextSegment"
        }

        public static var localizedName: String {
            "生词"
        }

        public var id: UUID
        public var createdAt: Date
        public var contextID: UUID?
        public var collectionID: UUID?
        public var segment: Segment
        public var text: String
        /// Lemma of the text, if the text is a word.
        ///
        /// A segment can necessarily not have a lemma, because it isn't a word.
        public var lemma: String?
        public var pos: PartOfSpeech?
        public var synonym: String?
        public var tag: ContextModel.TokenTag?
        /// Sense generated by LLM.
        ///
        /// Exists if there isn't a sense in the dictionary.
        public var sense: LocaledStringDict?
        /// Descriptons generated by LLM that is used to describe the segment with the context.
        public var desc: LocaledStringDict
        /// Sense ID of the entry sense that this segment belongs to.
        ///
        /// This is used to link the segment to the entry sense.
        public var entrySense: EntrySense?

        public var dictionaryName: String?
        /// Entry ID of the entry that this segment belongs to.
        ///
        /// This is used to link the segment to the entry.
        public var entryID: ID?

        public var reviewState: SegmentReview.State

        public var temporary: Bool

        // if the lemma is nil, then use the text as the lemma
        public var normalizedLemma: String {
            lemma ?? text
        }

        public var cacheState: Int?

        public var range: [Int] {
            get {
                switch segment {
                case .textRange(let segmentTextRange):
                    return [segmentTextRange.lowerBound, segmentTextRange.upperBound]
                }

            }
            set {
                guard newValue.count == 2 else {
                    return
                }

                let lowerBound = newValue[0]
                let upperBound = newValue[1]

                switch segment {
                case .textRange(var segmentTextRange):
                    segmentTextRange = CharacterRange(lowerBound: lowerBound, upperBound: upperBound)
                    segment = .textRange(segmentTextRange)
                }
            }
        }

        // optional has context item
        public var context: ContextModel.Context?

        public var textRange: CharacterRange? {
            switch segment {
            case .textRange(let segmentTextRange):
                return segmentTextRange
            }
        }

        public func subtextRange(from string: String) -> Range<String.Index>? {
            switch segment {
            case .textRange(let range):
                // Guard to ensure the range is within bounds
                guard range.lowerBound >= 0, range.upperBound <= string.count, range.lowerBound < range.upperBound else {
                    return nil
                }

                let start = string.index(string.startIndex, offsetBy: range.lowerBound)
                let end = string.index(string.startIndex, offsetBy: range.upperBound)
                return start..<end
            }
        }

        #if !os(Linux)
            public func subtextRange(from aString: AttributedString) -> Range<AttributedString.Index>? {
                let string = NSAttributedString(aString).string

                switch segment {
                case .textRange(let range):
                    // Guard to ensure the range is within bounds
                    guard range.lowerBound >= 0, range.upperBound <= string.count, range.lowerBound < range.upperBound else {
                        return nil
                    }

                    let start = aString.index(aString.startIndex, offsetByCharacters: range.lowerBound)
                    let end = aString.index(aString.startIndex, offsetByCharacters: range.upperBound)

                    return start..<end
                }
            }
        #endif

        public init(
            id: UUID = .init(),
            createdAt: Date = .now,
            contextID: UUID? = nil,
            segment: Segment = .textRange(.placeholder),
            text: String = "",
            lemma: String? = nil,
            pos: PartOfSpeech? = nil,
            synonym: String? = nil,
            sense: LocaledStringDict = [:],
            desc: LocaledStringDict = [:],
            entrySense: EntrySense? = nil,
            context: Context? = nil,
            reviewState: SegmentReview.State = .unfamiliar,
            temporary: Bool = false,
            cacheState: Int = 0
        ) {
            self.id = id
            self.createdAt = createdAt
            self.contextID = contextID
            self.segment = segment
            self.temporary = temporary
            self.text = text
            self.lemma = lemma
            self.pos = pos
            self.synonym = synonym
            self.sense = sense
            self.entrySense = entrySense
            self.desc = desc
            self.context = context
            self.reviewState = reviewState
            self.cacheState = cacheState
        }

        public init?(
            id: UUID,
            createdAt: Date = .now,
            contextID: UUID? = nil,
            segmentString: String?,
            text: String = "",
            lemma: String? = nil,
            pos: PartOfSpeech? = nil,
            synonym: String? = nil,
            sense: LocaledStringDict = [:],
            desc: LocaledStringDict = [:],
            context: Context? = nil,
            reviewState: SegmentReview.State = .unfamiliar,
            temporary: Bool = false,
            cacheState: Int = 0
        ) {
            guard let segmentString,
                let textSegment = CharacterRange(string: segmentString)
            else {
                return nil
            }

            self.id = id
            self.createdAt = createdAt
            self.contextID = contextID
            self.temporary = temporary
            self.segment = .textRange(textSegment)
            self.text = text
            self.lemma = lemma
            self.pos = pos
            self.synonym = synonym
            self.sense = sense
            self.desc = desc
            self.context = context
            self.reviewState = reviewState
            self.cacheState = cacheState
        }

        public init() {
            self.init(id: .init())
        }
    }
}

extension ContextModel.ContextSegment {
    public enum Segment: Hashable, CoSendable {
        case textRange(CharacterRange)

        public var textRange: CharacterRange? {
            if case .textRange(let range) = self {
                return range
            }

            return nil
        }
    }
}
